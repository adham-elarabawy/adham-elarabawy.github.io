{"version":3,"file":"98f88bb309ab150405dbe39f3f4abd4ff9d2e3ef-2f49c9738a574a778517.js","mappings":"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","sources":["webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Center/Center.module.css.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Center/Center.mjs","webpack://my-gatsby-site/./node_modules/@mantine/hooks/esm/use-merged-ref/use-merged-ref.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/core/utils/is-element/is-element.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/core/utils/get-default-z-index/get-default-z-index.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/core/DirectionProvider/DirectionProvider.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Floating/get-floating-position/get-floating-position.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Floating/FloatingArrow/get-arrow-position-styles.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Floating/FloatingArrow/FloatingArrow.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Portal/Portal.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Portal/OptionalPortal.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Transition/get-transition-props/get-transition-props.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/core/Box/get-style-object/get-style-object.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs","webpack://my-gatsby-site/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/Tooltip.module.css.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/TooltipFloating.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/TooltipFloating/use-floating-tooltip.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.context.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/TooltipGroup/TooltipGroup.mjs","webpack://my-gatsby-site/./node_modules/@mantine/hooks/esm/use-id/use-react-id.mjs","webpack://my-gatsby-site/./node_modules/@mantine/hooks/esm/use-id/use-id.mjs","webpack://my-gatsby-site/./node_modules/@mantine/hooks/esm/utils/random-id/random-id.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/use-tooltip.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Floating/use-floating-auto-update.mjs","webpack://my-gatsby-site/./node_modules/@mantine/core/esm/components/Tooltip/Tooltip.mjs"],"sourcesContent":["'use client';\nvar classes = {\"root\":\"m-4451eb3a\"};\n\nexport { classes as default };\n//# sourceMappingURL=Center.module.css.mjs.map\n","'use client';\nimport React from 'react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport { Box } from '../../core/Box/Box.mjs';\nimport { polymorphicFactory } from '../../core/factory/polymorphic-factory.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\nimport classes from './Center.module.css.mjs';\n\nconst defaultProps = {};\nconst Center = polymorphicFactory((_props, ref) => {\n  const props = useProps(\"Center\", defaultProps, _props);\n  const { classNames, className, style, styles, unstyled, vars, inline, mod, ...others } = props;\n  const getStyles = useStyles({\n    name: \"Center\",\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    vars\n  });\n  return /* @__PURE__ */ React.createElement(Box, { ref, mod: [{ inline }, mod], ...getStyles(\"root\"), ...others });\n});\nCenter.classes = classes;\nCenter.displayName = \"@mantine/core/Center\";\n\nexport { Center };\n//# sourceMappingURL=Center.mjs.map\n","'use client';\nimport { useCallback } from 'react';\n\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (typeof ref === \"object\" && ref !== null && \"current\" in ref) {\n    ref.current = value;\n  }\n}\nfunction mergeRefs(...refs) {\n  return (node) => {\n    refs.forEach((ref) => assignRef(ref, node));\n  };\n}\nfunction useMergedRef(...refs) {\n  return useCallback(mergeRefs(...refs), refs);\n}\n\nexport { assignRef, mergeRefs, useMergedRef };\n//# sourceMappingURL=use-merged-ref.mjs.map\n","'use client';\nimport React from 'react';\n\nfunction isElement(value) {\n  if (Array.isArray(value) || value === null) {\n    return false;\n  }\n  if (typeof value === \"object\") {\n    if (value.type === React.Fragment) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport { isElement };\n//# sourceMappingURL=is-element.mjs.map\n","'use client';\nconst elevations = {\n  app: 100,\n  modal: 200,\n  popover: 300,\n  overlay: 400,\n  max: 9999\n};\nfunction getDefaultZIndex(level) {\n  return elevations[level];\n}\n\nexport { getDefaultZIndex };\n//# sourceMappingURL=get-default-z-index.mjs.map\n","'use client';\nimport React, { createContext, useContext, useState } from 'react';\nimport { useIsomorphicEffect } from '@mantine/hooks';\n\nconst DirectionContext = createContext({\n  dir: \"ltr\",\n  toggleDirection: () => {\n  },\n  setDirection: () => {\n  }\n});\nfunction useDirection() {\n  return useContext(DirectionContext);\n}\nfunction DirectionProvider({\n  children,\n  initialDirection = \"ltr\",\n  detectDirection = true\n}) {\n  const [dir, setDir] = useState(initialDirection);\n  const setDirection = (direction) => {\n    setDir(direction);\n    document.documentElement.setAttribute(\"dir\", direction);\n  };\n  const toggleDirection = () => setDirection(dir === \"ltr\" ? \"rtl\" : \"ltr\");\n  useIsomorphicEffect(() => {\n    if (detectDirection) {\n      const direction = document.documentElement.getAttribute(\"dir\");\n      if (direction === \"rtl\" || direction === \"ltr\") {\n        setDirection(direction);\n      }\n    }\n  }, []);\n  return /* @__PURE__ */ React.createElement(DirectionContext.Provider, { value: { dir, toggleDirection, setDirection } }, children);\n}\n\nexport { DirectionContext, DirectionProvider, useDirection };\n//# sourceMappingURL=DirectionProvider.mjs.map\n","'use client';\nfunction getFloatingPosition(dir, position) {\n  if (dir === \"rtl\" && (position.includes(\"right\") || position.includes(\"left\"))) {\n    const [side, placement] = position.split(\"-\");\n    const flippedPosition = side === \"right\" ? \"left\" : \"right\";\n    return placement === void 0 ? flippedPosition : `${flippedPosition}-${placement}`;\n  }\n  return position;\n}\n\nexport { getFloatingPosition };\n//# sourceMappingURL=get-floating-position.mjs.map\n","'use client';\nimport { rem } from '../../../core/utils/units-converters/rem.mjs';\nimport 'react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\n\nfunction horizontalSide(placement, arrowY, arrowOffset, arrowPosition) {\n  if (placement === \"center\" || arrowPosition === \"center\") {\n    return { top: arrowY };\n  }\n  if (placement === \"end\") {\n    return { bottom: arrowOffset };\n  }\n  if (placement === \"start\") {\n    return { top: arrowOffset };\n  }\n  return {};\n}\nfunction verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir) {\n  if (placement === \"center\" || arrowPosition === \"center\") {\n    return { left: arrowX };\n  }\n  if (placement === \"end\") {\n    return { [dir === \"ltr\" ? \"right\" : \"left\"]: arrowOffset };\n  }\n  if (placement === \"start\") {\n    return { [dir === \"ltr\" ? \"left\" : \"right\"]: arrowOffset };\n  }\n  return {};\n}\nconst radiusByFloatingSide = {\n  bottom: \"borderTopLeftRadius\",\n  left: \"borderTopRightRadius\",\n  right: \"borderBottomLeftRadius\",\n  top: \"borderBottomRightRadius\"\n};\nfunction getArrowPositionStyles({\n  position,\n  arrowSize,\n  arrowOffset,\n  arrowRadius,\n  arrowPosition,\n  arrowX,\n  arrowY,\n  dir\n}) {\n  const [side, placement = \"center\"] = position.split(\"-\");\n  const baseStyles = {\n    width: rem(arrowSize),\n    height: rem(arrowSize),\n    transform: \"rotate(45deg)\",\n    position: \"absolute\",\n    [radiusByFloatingSide[side]]: rem(arrowRadius)\n  };\n  const arrowPlacement = rem(-arrowSize / 2);\n  if (side === \"left\") {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      right: arrowPlacement,\n      borderLeftColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    };\n  }\n  if (side === \"right\") {\n    return {\n      ...baseStyles,\n      ...horizontalSide(placement, arrowY, arrowOffset, arrowPosition),\n      left: arrowPlacement,\n      borderRightColor: \"transparent\",\n      borderTopColor: \"transparent\"\n    };\n  }\n  if (side === \"top\") {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      bottom: arrowPlacement,\n      borderTopColor: \"transparent\",\n      borderLeftColor: \"transparent\"\n    };\n  }\n  if (side === \"bottom\") {\n    return {\n      ...baseStyles,\n      ...verticalSide(placement, arrowX, arrowOffset, arrowPosition, dir),\n      top: arrowPlacement,\n      borderBottomColor: \"transparent\",\n      borderRightColor: \"transparent\"\n    };\n  }\n  return {};\n}\n\nexport { getArrowPositionStyles };\n//# sourceMappingURL=get-arrow-position-styles.mjs.map\n","'use client';\nimport React, { forwardRef } from 'react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport '../../../core/Box/Box.mjs';\nimport { useDirection } from '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { getArrowPositionStyles } from './get-arrow-position-styles.mjs';\n\nconst FloatingArrow = forwardRef(\n  ({\n    position,\n    arrowSize,\n    arrowOffset,\n    arrowRadius,\n    arrowPosition,\n    visible,\n    arrowX,\n    arrowY,\n    style,\n    ...others\n  }, ref) => {\n    const { dir } = useDirection();\n    if (!visible) {\n      return null;\n    }\n    return /* @__PURE__ */ React.createElement(\n      \"div\",\n      {\n        ...others,\n        ref,\n        style: {\n          ...style,\n          ...getArrowPositionStyles({\n            position,\n            arrowSize,\n            arrowOffset,\n            arrowRadius,\n            arrowPosition,\n            dir,\n            arrowX,\n            arrowY\n          })\n        }\n      }\n    );\n  }\n);\nFloatingArrow.displayName = \"@mantine/core/FloatingArrow\";\n\nexport { FloatingArrow };\n//# sourceMappingURL=FloatingArrow.mjs.map\n","'use client';\nimport React, { forwardRef, useState, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport { useIsomorphicEffect, assignRef } from '@mantine/hooks';\nimport 'clsx';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../core/Box/Box.mjs';\nimport '../../core/DirectionProvider/DirectionProvider.mjs';\n\nfunction createPortalNode(props) {\n  const node = document.createElement(\"div\");\n  node.setAttribute(\"data-portal\", \"true\");\n  typeof props.className === \"string\" && node.classList.add(...props.className.split(\" \").filter(Boolean));\n  typeof props.style === \"object\" && Object.assign(node.style, props.style);\n  typeof props.id === \"string\" && node.setAttribute(\"id\", props.id);\n  return node;\n}\nconst defaultProps = {};\nconst Portal = forwardRef((props, ref) => {\n  const { children, target, ...others } = useProps(\"Portal\", defaultProps, props);\n  const [mounted, setMounted] = useState(false);\n  const nodeRef = useRef(null);\n  useIsomorphicEffect(() => {\n    setMounted(true);\n    nodeRef.current = !target ? createPortalNode(others) : typeof target === \"string\" ? document.querySelector(target) : target;\n    assignRef(ref, nodeRef.current);\n    if (!target && nodeRef.current) {\n      document.body.appendChild(nodeRef.current);\n    }\n    return () => {\n      if (!target && nodeRef.current) {\n        document.body.removeChild(nodeRef.current);\n      }\n    };\n  }, [target]);\n  if (!mounted || !nodeRef.current) {\n    return null;\n  }\n  return createPortal(/* @__PURE__ */ React.createElement(React.Fragment, null, children), nodeRef.current);\n});\nPortal.displayName = \"@mantine/core/Portal\";\n\nexport { Portal };\n//# sourceMappingURL=Portal.mjs.map\n","'use client';\nimport React from 'react';\nimport { Portal } from './Portal.mjs';\n\nfunction OptionalPortal({ withinPortal = true, children, ...others }) {\n  if (withinPortal) {\n    return /* @__PURE__ */ React.createElement(Portal, { ...others }, children);\n  }\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);\n}\nOptionalPortal.displayName = \"@mantine/core/OptionalPortal\";\n\nexport { OptionalPortal };\n//# sourceMappingURL=OptionalPortal.mjs.map\n","'use client';\nconst defaultTransition = {\n  duration: 100,\n  transition: \"fade\"\n};\nfunction getTransitionProps(transitionProps, componentTransition) {\n  return { ...defaultTransition, ...componentTransition, ...transitionProps };\n}\n\nexport { getTransitionProps };\n//# sourceMappingURL=get-transition-props.mjs.map\n","'use client';\nfunction getStyleObject(style, theme) {\n  if (Array.isArray(style)) {\n    return [...style].reduce(\n      (acc, item) => ({ ...acc, ...getStyleObject(item, theme) }),\n      {}\n    );\n  }\n  if (typeof style === \"function\") {\n    return style(theme);\n  }\n  if (style == null) {\n    return {};\n  }\n  return style;\n}\n\nexport { getStyleObject };\n//# sourceMappingURL=get-style-object.mjs.map\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { isShadowRoot, isHTMLElement } from '@floating-ui/utils/dom';\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n\nexport { TYPEABLE_SELECTOR, activeElement, contains, getDocument, getPlatform, getTarget, getUserAgent, isAndroid, isEventTargetWithin, isJSDOM, isMac, isMouseLikePointerType, isReactEvent, isRootElement, isSafari, isTypeableCombobox, isTypeableElement, isVirtualClick, isVirtualPointerEvent, stopEvent };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(data.floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$1({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$1({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // biome-ignore lint/suspicious/noSelfCompare: in source\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\nexport { arrow, useFloating };\n","import * as React from 'react';\nimport { useLayoutEffect, useEffect, useRef } from 'react';\nimport { stopEvent, getDocument, isMouseLikePointerType, contains, activeElement, isSafari, isTypeableCombobox, isVirtualClick, isVirtualPointerEvent, getTarget, getPlatform, isTypeableElement, isReactEvent, isRootElement, isEventTargetWithin, isMac, getUserAgent } from '@floating-ui/react/utils';\nimport { floor } from '@floating-ui/utils';\nimport { platform, getOverflowAncestors, useFloating as useFloating$1, offset, detectOverflow } from '@floating-ui/react-dom';\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/react-dom';\nimport { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode, getParentNode, getComputedStyle } from '@floating-ui/utils/dom';\nimport { tabbable } from 'tabbable';\nimport { createPortal, flushSync } from 'react-dom';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n  }, refs);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = React[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = floor(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = floor(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      return firstCellIndex + sizes[index].width - 1;\n    case 'bl':\n      return firstCellIndex + (sizes[index].height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/React.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = React.useState(() => new Map());\n  const register = React.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = React.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(FloatingListContext.Provider, {\n    value: React.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = React.useState(null);\n  const componentRef = React.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = React.useContext(FloatingListContext);\n  const ref = React.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return React.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/React.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/React.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/React.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arent part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/React.forwardRef(function Composite(_ref, forwardedRef) {\n  let {\n    render,\n    orientation = 'both',\n    loop = true,\n    cols = 1,\n    disabledIndices = [],\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    itemSizes,\n    dense = false,\n    ...props\n  } = _ref;\n  const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = React.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = React.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n      nextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')\n      })]; // navigated cell will never be nullish\n    }\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = {\n    ...props,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      props.onKeyDown == null || props.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/React.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/React.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n  let {\n    render,\n    ...props\n  } = _ref2;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = React.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...props,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      props.onFocus == null || props.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n  }, []);\n  React.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = React[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/React.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = _ref;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d ||\n  // biome-ignore lint/style/useTemplate: readability\n  'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : ''),\n      ...restStyle\n    }\n  }), strokeWidth > 0 && /*#__PURE__*/React.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/React.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/React.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\n\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/React.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => React.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/React.createElement(FloatingNodeContext.Provider, {\n    value: React.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = React.useRef([]);\n  const addNode = React.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = React.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = React.useState(() => createPubSub())[0];\n  return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {\n    value: React.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction useLatestRef(value) {\n  const ref = useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !isMouseLikePointerType(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = React.useRef();\n  const timeoutRef = React.useRef();\n  const handlerRef = React.useRef();\n  const restTimeoutRef = React.useRef();\n  const blockMouseMoveRef = React.useRef(true);\n  const performedPointerEventsMutationRef = React.useRef(false);\n  const unbindMouseMoveRef = React.useRef(() => {});\n  const isHoverOpen = React.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  React.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = getDocument(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = React.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = React.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = React.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = getDocument(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = getDocument(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...context,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !contains(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...context,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      })(event);\n    }\n    if (isElement(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = getDocument(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if (isElement(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  React.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\n\nconst FloatingDelayGroupContext = /*#__PURE__*/React.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => React.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = React.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = React.useRef(null);\n  const setCurrentId = React.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/React.createElement(FloatingDelayGroupContext.Provider, {\n    value: React.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n};\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\n\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = getDocument(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = tabbable(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = tabbable(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    // biome-ignore lint/performance/noDelete: purity\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = React.useState();\n  index(() => {\n    if (isSafari()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/React.createElement(\"span\", _extends({}, props, restProps));\n});\n\nconst PortalContext = /*#__PURE__*/React.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = React.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const portalNodeRef = React.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !isElement(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = React.useState(null);\n  const beforeOutsideRef = React.useRef(null);\n  const afterOutsideRef = React.useRef(null);\n  const beforeInsideRef = React.useRef(null);\n  const afterInsideRef = React.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  React.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/React.createElement(PortalContext.Provider, {\n    value: React.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => React.useContext(PortalContext);\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  if (element && getNodeName(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/React.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/React.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = React.useRef(null);\n  const endDismissButtonRef = React.useRef(null);\n  const preventReturnFocusRef = React.useRef(false);\n  const isPointerDownRef = React.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = React.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? tabbable(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = React.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  React.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if (contains(floating, activeElement(getDocument(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          stopEvent(event);\n        }\n        const els = getTabbableElements();\n        const target = getTarget(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          stopEvent(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          stopEvent(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = getDocument(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  React.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && isHTMLElement(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  React.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = contains(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = getDocument(floating);\n    const previouslyFocusedElement = activeElement(doc);\n    const contextData = dataRef.current;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = activeElement(doc);\n      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored  leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || activeElement(getDocument(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/React.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\n\nconst activeLocks = /*#__PURE__*/new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/React.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n    lockScroll = false,\n    ...rest\n  } = _ref;\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  }));\n});\n\nfunction isButtonTarget(event) {\n  return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return isTypeableElement(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = React.useRef();\n  const didKeyDownRef = React.useRef(false);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if (isMouseLikePointerType(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\n\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = React.useRef(false);\n  const cleanupListenerRef = React.useRef(null);\n  const [pointerType, setPointerType] = React.useState();\n  const [reactive, setReactive] = React.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n  const addListener = React.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = getWindow(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = getTarget(event);\n      if (!contains(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`\n  React.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  React.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  React.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = React.useRef(false);\n  const endedOrStartedInsideRef = React.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = getTarget(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = getDocument(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = isElement(target) ? target : null;\n    while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n      const nextParent = getParentNode(targetRootAncestor);\n      if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && isElement(target) && !isRootElement(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !contains(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if (isHTMLElement(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = getComputedStyle(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if (isEventTargetWithin(event, floating) || isEventTargetWithin(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  React.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = getDocument(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if (isElement(domReference)) {\n        ancestors = getOverflowAncestors(domReference);\n      }\n      if (isElement(floating)) {\n        ancestors = ancestors.concat(getOverflowAncestors(floating));\n      }\n      if (!isElement(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat(getOverflowAncestors(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  React.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\n\nlet devMessageSet;\nif (process.env.NODE_ENV !== \"production\") {\n  devMessageSet = /*#__PURE__*/new Set();\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements2;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  if (process.env.NODE_ENV !== \"production\") {\n    var _options$elements;\n    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';\n    if ((_options$elements = options.elements) != null && _options$elements.reference && !isElement(options.elements.reference)) {\n      var _devMessageSet;\n      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n        console.error(err);\n      }\n    }\n  }\n  const [_domReference, setDomReference] = React.useState(null);\n  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n  const position = useFloating$1(options);\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = React.useRef(null);\n  const dataRef = React.useRef({});\n  const events = React.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = React.useCallback(node => {\n    const positionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = React.useCallback(node => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = React.useMemo(() => ({\n    ...position,\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = React.useRef(false);\n  const timeoutRef = React.useRef();\n  const keyboardModalityRef = React.useRef(true);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = getWindow(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && isHTMLElement(domReference) && domReference === activeElement(getDocument(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [domReference, open, enabled]);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if (isVirtualPointerEvent(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = getTarget(event.nativeEvent);\n          if (visibleOnly && isElement(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if (isSafari() && isMac()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !isTypeableElement(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = activeElement(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            // We can not rely on relatedTarget to point to the correct element\n            // as it will only point to the shadow host of the newly focused element\n            // and not the element that actually has received focus if it is located\n            // inside a shadow root.\n            if (contains(refs.floating.current, activeEl) || contains(domReference, activeEl) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\n\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getReferenceProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getFloatingProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getItemProps = React.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  propsList.map(key => key == null ? void 0 : key.item));\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (process.env.NODE_ENV !== \"production\") {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = React.useRef(focusItemOnOpen);\n  const indexRef = React.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = React.useRef(null);\n  const isPointerModalityRef = React.useRef(true);\n  const previousOnNavigateRef = React.useRef(onNavigate);\n  const previousMountedRef = React.useRef(!!floating);\n  const forceSyncFocus = React.useRef(false);\n  const forceScrollIntoViewRef = React.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = React.useState();\n  const [virtualId, setVirtualId] = React.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = activeElement(getDocument(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = React.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      ...(focusItemOnHover && {\n        onMouseMove(_ref3) {\n          let {\n            currentTarget\n          } = _ref3;\n          syncCurrentTarget(currentTarget);\n        },\n        onPointerLeave(_ref4) {\n          let {\n            pointerType\n          } = _ref4;\n          if (!isPointerModalityRef.current || pointerType === 'touch') {\n            return;\n          }\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n          onNavigate(null);\n          if (!virtual) {\n            enqueueFocus(refs.floating.current, {\n              preventScroll: true\n            });\n          }\n        }\n      })\n    };\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if (isHTMLElement(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        stopEvent(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        stopEvent(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n        indexRef.current = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl'),\n          stopEvent: true\n        })]; // navigated cell will never be nullish\n\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  stopEvent(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  stopEvent(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      },\n      floating: {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(!isTypeableCombobox(domReference) && ariaActiveDescendantProp),\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      },\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return React.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined,\n        ...(ariaRole === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(ariaRole === 'menu' && {\n          id: referenceId\n        }),\n        ...(ariaRole === 'menu' && isNested && {\n          role: 'menuitem'\n        }),\n        ...(role === 'select' && {\n          'aria-autocomplete': 'none'\n        }),\n        ...(role === 'combobox' && {\n          'aria-autocomplete': 'list'\n        })\n      },\n      floating: {\n        ...floatingProps,\n        ...(ariaRole === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      },\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = {\n          role: 'option',\n          ...(active && {\n            id: floatingId + \"-option\"\n          })\n        };\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return {\n              ...commonProps,\n              'aria-selected': active && selected\n            };\n          case 'combobox':\n            {\n              return {\n                ...commonProps,\n                ...(active && {\n                  'aria-selected': true\n                })\n              };\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = React.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  React.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = React.useState(false);\n  const [status, setStatus] = React.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setInitiated(true);\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = React.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = React.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = React.useRef();\n  const stringRef = React.useRef('');\n  const prevIndexRef = React.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = React.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        flushSync(() => onFallbackChange(true));\n      } else {\n        flushSync(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React.useRef(false);\n  const prevScrollTopRef = React.useRef(null);\n  const initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              flushSync(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\nexport { Composite, CompositeItem, FloatingArrow, FloatingDelayGroup, FloatingFocusManager, FloatingList, FloatingNode, FloatingOverlay, FloatingPortal, FloatingTree, inner, safePolygon, useClick, useClientPoint, useDelayGroup, useDelayGroupContext, useDismiss, useFloating, useFloatingNodeId, useFloatingParentNodeId, useFloatingPortalNode, useFloatingTree, useFocus, useHover, useId, useInnerOffset, useInteractions, useListItem, useListNavigation, useMergeRefs, useRole, useTransitionStatus, useTransitionStyles, useTypeahead };\n","'use client';\nvar classes = {\"tooltip\":\"m-1b3c8819\",\"arrow\":\"m-f898399f\"};\n\nexport { classes as default };\n//# sourceMappingURL=Tooltip.module.css.mjs.map\n","'use client';\nimport React, { cloneElement } from 'react';\nimport { useMergedRef } from '@mantine/hooks';\nimport { isElement } from '../../../core/utils/is-element/is-element.mjs';\nimport { getDefaultZIndex } from '../../../core/utils/get-default-z-index/get-default-z-index.mjs';\nimport { getRadius } from '../../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport 'clsx';\nimport { getThemeColor } from '../../../core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport { useMantineTheme } from '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../../core/MantineProvider/use-props/use-props.mjs';\nimport { useStyles } from '../../../core/styles-api/use-styles/use-styles.mjs';\nimport { getStyleObject } from '../../../core/Box/get-style-object/get-style-object.mjs';\nimport { Box } from '../../../core/Box/Box.mjs';\nimport { factory } from '../../../core/factory/factory.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport '../../Portal/Portal.mjs';\nimport { OptionalPortal } from '../../Portal/OptionalPortal.mjs';\nimport { useFloatingTooltip } from './use-floating-tooltip.mjs';\nimport classes from '../Tooltip.module.css.mjs';\n\nconst defaultProps = {\n  refProp: \"ref\",\n  withinPortal: true,\n  offset: 10,\n  position: \"right\",\n  zIndex: getDefaultZIndex(\"popover\")\n};\nconst varsResolver = createVarsResolver((theme, { radius, color }) => ({\n  tooltip: {\n    \"--tooltip-radius\": radius === void 0 ? void 0 : getRadius(radius),\n    \"--tooltip-bg\": color ? getThemeColor(color, theme) : void 0,\n    \"--tooltip-color\": color ? \"var(--mantine-color-white)\" : void 0\n  }\n}));\nconst TooltipFloating = factory((_props, ref) => {\n  const props = useProps(\"TooltipFloating\", defaultProps, _props);\n  const {\n    children,\n    refProp,\n    withinPortal,\n    style,\n    className,\n    classNames,\n    styles,\n    unstyled,\n    radius,\n    color,\n    label,\n    offset,\n    position,\n    multiline,\n    zIndex,\n    disabled,\n    variant,\n    vars,\n    portalProps,\n    ...others\n  } = props;\n  const theme = useMantineTheme();\n  const getStyles = useStyles({\n    name: \"TooltipFloating\",\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    rootSelector: \"tooltip\",\n    vars,\n    varsResolver\n  });\n  const { handleMouseMove, x, y, opened, boundaryRef, floating, setOpened } = useFloatingTooltip({\n    offset,\n    position\n  });\n  if (!isElement(children)) {\n    throw new Error(\n      \"[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported\"\n    );\n  }\n  const targetRef = useMergedRef(boundaryRef, children.ref, ref);\n  const onMouseEnter = (event) => {\n    children.props.onMouseEnter?.(event);\n    handleMouseMove(event);\n    setOpened(true);\n  };\n  const onMouseLeave = (event) => {\n    children.props.onMouseLeave?.(event);\n    setOpened(false);\n  };\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(OptionalPortal, { ...portalProps, withinPortal }, /* @__PURE__ */ React.createElement(\n    Box,\n    {\n      ...others,\n      ...getStyles(\"tooltip\", {\n        style: {\n          ...getStyleObject(style, theme),\n          zIndex,\n          display: !disabled && opened ? \"block\" : \"none\",\n          top: (y && Math.round(y)) ?? \"\",\n          left: (x && Math.round(x)) ?? \"\"\n        }\n      }),\n      variant,\n      ref: floating,\n      mod: { multiline }\n    },\n    label\n  )), cloneElement(children, {\n    ...children.props,\n    [refProp]: targetRef,\n    onMouseEnter,\n    onMouseLeave\n  }));\n});\nTooltipFloating.classes = classes;\nTooltipFloating.displayName = \"@mantine/core/TooltipFloating\";\n\nexport { TooltipFloating };\n//# sourceMappingURL=TooltipFloating.mjs.map\n","'use client';\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { useFloating, shift, getOverflowAncestors } from '@floating-ui/react';\n\nfunction useFloatingTooltip({\n  offset,\n  position\n}) {\n  const [opened, setOpened] = useState(false);\n  const boundaryRef = useRef();\n  const { x, y, elements, refs, update, placement } = useFloating({\n    placement: position,\n    middleware: [\n      shift({\n        crossAxis: true,\n        padding: 5,\n        rootBoundary: \"document\"\n      })\n    ]\n  });\n  const horizontalOffset = placement.includes(\"right\") ? offset : position.includes(\"left\") ? offset * -1 : 0;\n  const verticalOffset = placement.includes(\"bottom\") ? offset : position.includes(\"top\") ? offset * -1 : 0;\n  const handleMouseMove = useCallback(\n    ({ clientX, clientY }) => {\n      refs.setPositionReference({\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: clientX,\n            y: clientY,\n            left: clientX + horizontalOffset,\n            top: clientY + verticalOffset,\n            right: clientX,\n            bottom: clientY\n          };\n        }\n      });\n    },\n    [elements.reference]\n  );\n  useEffect(() => {\n    if (refs.floating.current) {\n      const boundary = boundaryRef.current;\n      boundary.addEventListener(\"mousemove\", handleMouseMove);\n      const parents = getOverflowAncestors(refs.floating.current);\n      parents.forEach((parent) => {\n        parent.addEventListener(\"scroll\", update);\n      });\n      return () => {\n        boundary.removeEventListener(\"mousemove\", handleMouseMove);\n        parents.forEach((parent) => {\n          parent.removeEventListener(\"scroll\", update);\n        });\n      };\n    }\n    return void 0;\n  }, [elements.reference, refs.floating.current, update, handleMouseMove, opened]);\n  return { handleMouseMove, x, y, opened, setOpened, boundaryRef, floating: refs.setFloating };\n}\n\nexport { useFloatingTooltip };\n//# sourceMappingURL=use-floating-tooltip.mjs.map\n","'use client';\nimport { createContext, useContext } from 'react';\n\nconst TooltipGroupContext = createContext(false);\nconst TooltipGroupProvider = TooltipGroupContext.Provider;\nconst useTooltipGroupContext = () => useContext(TooltipGroupContext);\n\nexport { TooltipGroupProvider, useTooltipGroupContext };\n//# sourceMappingURL=TooltipGroup.context.mjs.map\n","'use client';\nimport React from 'react';\nimport { FloatingDelayGroup } from '@floating-ui/react';\nimport '@mantine/hooks';\nimport 'clsx';\nimport '../../../core/MantineProvider/Mantine.context.mjs';\nimport '../../../core/MantineProvider/default-theme.mjs';\nimport '../../../core/MantineProvider/MantineProvider.mjs';\nimport '../../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../../core/MantineProvider/use-props/use-props.mjs';\nimport '../../../core/Box/Box.mjs';\nimport '../../../core/DirectionProvider/DirectionProvider.mjs';\nimport { TooltipGroupProvider } from './TooltipGroup.context.mjs';\n\nconst defaultProps = {\n  openDelay: 0,\n  closeDelay: 0\n};\nfunction TooltipGroup(props) {\n  const { openDelay, closeDelay, children } = useProps(\"TooltipGroup\", defaultProps, props);\n  return /* @__PURE__ */ React.createElement(TooltipGroupProvider, { value: true }, /* @__PURE__ */ React.createElement(FloatingDelayGroup, { delay: { open: openDelay, close: closeDelay } }, children));\n}\nTooltipGroup.displayName = \"@mantine/core/TooltipGroup\";\n\nexport { TooltipGroup };\n//# sourceMappingURL=TooltipGroup.mjs.map\n","'use client';\nimport React from 'react';\n\nconst __useId = React[\"useId\".toString()] || (() => void 0);\nfunction useReactId() {\n  const id = __useId();\n  return id ? `mantine-${id.replace(/:/g, \"\")}` : \"\";\n}\n\nexport { useReactId };\n//# sourceMappingURL=use-react-id.mjs.map\n","'use client';\nimport { useState } from 'react';\nimport { useIsomorphicEffect } from '../use-isomorphic-effect/use-isomorphic-effect.mjs';\nimport { randomId } from '../utils/random-id/random-id.mjs';\nimport { useReactId } from './use-react-id.mjs';\n\nfunction useId(staticId) {\n  const reactId = useReactId();\n  const [uuid, setUuid] = useState(reactId);\n  useIsomorphicEffect(() => {\n    setUuid(randomId());\n  }, []);\n  if (typeof staticId === \"string\") {\n    return staticId;\n  }\n  if (typeof window === \"undefined\") {\n    return reactId;\n  }\n  return uuid;\n}\n\nexport { useId };\n//# sourceMappingURL=use-id.mjs.map\n","'use client';\nfunction randomId() {\n  return `mantine-${Math.random().toString(36).slice(2, 11)}`;\n}\n\nexport { randomId };\n//# sourceMappingURL=random-id.mjs.map\n","'use client';\nimport { useState, useCallback } from 'react';\nimport { useDelayGroupContext, useFloating, offset, shift, flip, arrow, inline, useInteractions, useHover, useFocus, useRole, useDismiss, useDelayGroup } from '@floating-ui/react';\nimport { useId, useDidUpdate } from '@mantine/hooks';\nimport { useFloatingAutoUpdate } from '../Floating/use-floating-auto-update.mjs';\nimport '../Floating/FloatingArrow/FloatingArrow.mjs';\nimport { useTooltipGroupContext } from './TooltipGroup/TooltipGroup.context.mjs';\n\nfunction useTooltip(settings) {\n  const [uncontrolledOpened, setUncontrolledOpened] = useState(false);\n  const controlled = typeof settings.opened === \"boolean\";\n  const opened = controlled ? settings.opened : uncontrolledOpened;\n  const withinGroup = useTooltipGroupContext();\n  const uid = useId();\n  const { delay: groupDelay, currentId, setCurrentId } = useDelayGroupContext();\n  const onChange = useCallback(\n    (_opened) => {\n      setUncontrolledOpened(_opened);\n      if (_opened) {\n        setCurrentId(uid);\n      }\n    },\n    [setCurrentId, uid]\n  );\n  const {\n    x,\n    y,\n    context,\n    refs,\n    update,\n    placement,\n    middlewareData: { arrow: { x: arrowX, y: arrowY } = {} }\n  } = useFloating({\n    strategy: settings.strategy,\n    placement: settings.position,\n    open: opened,\n    onOpenChange: onChange,\n    middleware: [\n      offset(settings.offset),\n      shift({ padding: 8 }),\n      flip(),\n      arrow({ element: settings.arrowRef, padding: settings.arrowOffset }),\n      ...settings.inline ? [inline()] : []\n    ]\n  });\n  const { getReferenceProps, getFloatingProps } = useInteractions([\n    useHover(context, {\n      enabled: settings.events?.hover,\n      delay: withinGroup ? groupDelay : { open: settings.openDelay, close: settings.closeDelay },\n      mouseOnly: !settings.events?.touch\n    }),\n    useFocus(context, { enabled: settings.events?.focus, visibleOnly: true }),\n    useRole(context, { role: \"tooltip\" }),\n    // cannot be used with controlled tooltip, page jumps\n    useDismiss(context, { enabled: typeof settings.opened === \"undefined\" }),\n    useDelayGroup(context, { id: uid })\n  ]);\n  useFloatingAutoUpdate({\n    opened,\n    position: settings.position,\n    positionDependencies: settings.positionDependencies,\n    floating: { refs, update }\n  });\n  useDidUpdate(() => {\n    settings.onPositionChange?.(placement);\n  }, [placement]);\n  const isGroupPhase = opened && currentId && currentId !== uid;\n  return {\n    x,\n    y,\n    arrowX,\n    arrowY,\n    reference: refs.setReference,\n    floating: refs.setFloating,\n    getFloatingProps,\n    getReferenceProps,\n    isGroupPhase,\n    opened,\n    placement\n  };\n}\n\nexport { useTooltip };\n//# sourceMappingURL=use-tooltip.mjs.map\n","'use client';\nimport { useState, useEffect } from 'react';\nimport { autoUpdate } from '@floating-ui/react';\nimport { useDidUpdate } from '@mantine/hooks';\n\nfunction useFloatingAutoUpdate({\n  opened,\n  floating,\n  position,\n  positionDependencies\n}) {\n  const [delayedUpdate, setDelayedUpdate] = useState(0);\n  useEffect(() => {\n    if (floating.refs.reference.current && floating.refs.floating.current) {\n      return autoUpdate(\n        floating.refs.reference.current,\n        floating.refs.floating.current,\n        floating.update\n      );\n    }\n    return void 0;\n  }, [\n    floating.refs.reference.current,\n    floating.refs.floating.current,\n    opened,\n    delayedUpdate,\n    position\n  ]);\n  useDidUpdate(() => {\n    floating.update();\n  }, positionDependencies);\n  useDidUpdate(() => {\n    setDelayedUpdate((c) => c + 1);\n  }, [opened]);\n}\n\nexport { useFloatingAutoUpdate };\n//# sourceMappingURL=use-floating-auto-update.mjs.map\n","'use client';\nimport React, { useRef, cloneElement } from 'react';\nimport cx from 'clsx';\nimport { useMergedRef } from '@mantine/hooks';\nimport { isElement } from '../../core/utils/is-element/is-element.mjs';\nimport { getDefaultZIndex } from '../../core/utils/get-default-z-index/get-default-z-index.mjs';\nimport { getRadius } from '../../core/utils/get-size/get-size.mjs';\nimport { createVarsResolver } from '../../core/styles-api/create-vars-resolver/create-vars-resolver.mjs';\nimport { getThemeColor } from '../../core/MantineProvider/color-functions/get-theme-color/get-theme-color.mjs';\nimport '../../core/MantineProvider/Mantine.context.mjs';\nimport '../../core/MantineProvider/default-theme.mjs';\nimport '../../core/MantineProvider/MantineProvider.mjs';\nimport '../../core/MantineProvider/MantineThemeProvider/MantineThemeProvider.mjs';\nimport { useProps } from '../../core/MantineProvider/use-props/use-props.mjs';\nimport { useStyles } from '../../core/styles-api/use-styles/use-styles.mjs';\nimport { Box } from '../../core/Box/Box.mjs';\nimport { factory } from '../../core/factory/factory.mjs';\nimport { useDirection } from '../../core/DirectionProvider/DirectionProvider.mjs';\nimport '@floating-ui/react';\nimport { getFloatingPosition } from '../Floating/get-floating-position/get-floating-position.mjs';\nimport { FloatingArrow } from '../Floating/FloatingArrow/FloatingArrow.mjs';\nimport '../Portal/Portal.mjs';\nimport { OptionalPortal } from '../Portal/OptionalPortal.mjs';\nimport '../Transition/transitions.mjs';\nimport { Transition } from '../Transition/Transition.mjs';\nimport { getTransitionProps } from '../Transition/get-transition-props/get-transition-props.mjs';\nimport { TooltipFloating } from './TooltipFloating/TooltipFloating.mjs';\nimport { TooltipGroup } from './TooltipGroup/TooltipGroup.mjs';\nimport { useTooltip } from './use-tooltip.mjs';\nimport classes from './Tooltip.module.css.mjs';\n\nconst defaultProps = {\n  position: \"top\",\n  refProp: \"ref\",\n  withinPortal: true,\n  inline: false,\n  arrowSize: 4,\n  arrowOffset: 5,\n  arrowRadius: 0,\n  arrowPosition: \"side\",\n  offset: 5,\n  transitionProps: { duration: 100, transition: \"fade\" },\n  events: { hover: true, focus: false, touch: false },\n  zIndex: getDefaultZIndex(\"popover\"),\n  positionDependencies: []\n};\nconst varsResolver = createVarsResolver((theme, { radius, color }) => ({\n  tooltip: {\n    \"--tooltip-radius\": radius === void 0 ? void 0 : getRadius(radius),\n    \"--tooltip-bg\": color ? getThemeColor(color, theme) : void 0,\n    \"--tooltip-color\": color ? \"var(--mantine-color-white)\" : void 0\n  }\n}));\nconst Tooltip = factory((_props, ref) => {\n  const props = useProps(\"Tooltip\", defaultProps, _props);\n  const {\n    children,\n    position,\n    refProp,\n    label,\n    openDelay,\n    closeDelay,\n    onPositionChange,\n    opened,\n    withinPortal,\n    radius,\n    color,\n    classNames,\n    styles,\n    unstyled,\n    style,\n    className,\n    withArrow,\n    arrowSize,\n    arrowOffset,\n    arrowRadius,\n    arrowPosition,\n    offset,\n    transitionProps,\n    multiline,\n    events,\n    zIndex,\n    disabled,\n    positionDependencies,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    inline,\n    variant,\n    keepMounted,\n    vars,\n    portalProps,\n    mod,\n    floatingStrategy,\n    ...others\n  } = useProps(\"Tooltip\", defaultProps, props);\n  const { dir } = useDirection();\n  const arrowRef = useRef(null);\n  const tooltip = useTooltip({\n    position: getFloatingPosition(dir, position),\n    closeDelay,\n    openDelay,\n    onPositionChange,\n    opened,\n    events,\n    arrowRef,\n    arrowOffset,\n    offset: typeof offset === \"number\" ? offset + (withArrow ? arrowSize / 2 : 0) : offset,\n    positionDependencies: [...positionDependencies, children],\n    inline,\n    strategy: floatingStrategy\n  });\n  const getStyles = useStyles({\n    name: \"Tooltip\",\n    props,\n    classes,\n    className,\n    style,\n    classNames,\n    styles,\n    unstyled,\n    rootSelector: \"tooltip\",\n    vars,\n    varsResolver\n  });\n  if (!isElement(children)) {\n    throw new Error(\n      \"[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported\"\n    );\n  }\n  const targetRef = useMergedRef(tooltip.reference, children.ref, ref);\n  const transition = getTransitionProps(transitionProps, { duration: 100, transition: \"fade\" });\n  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(OptionalPortal, { ...portalProps, withinPortal }, /* @__PURE__ */ React.createElement(\n    Transition,\n    {\n      ...transition,\n      keepMounted,\n      mounted: !disabled && !!tooltip.opened,\n      duration: tooltip.isGroupPhase ? 10 : transition.duration\n    },\n    (transitionStyles) => /* @__PURE__ */ React.createElement(\n      Box,\n      {\n        ...others,\n        variant,\n        mod: [{ multiline }, mod],\n        ...tooltip.getFloatingProps({\n          ref: tooltip.floating,\n          className: getStyles(\"tooltip\").className,\n          style: {\n            ...getStyles(\"tooltip\").style,\n            ...transitionStyles,\n            zIndex,\n            top: tooltip.y ?? 0,\n            left: tooltip.x ?? 0\n          }\n        })\n      },\n      label,\n      /* @__PURE__ */ React.createElement(\n        FloatingArrow,\n        {\n          ref: arrowRef,\n          arrowX: tooltip.arrowX,\n          arrowY: tooltip.arrowY,\n          visible: withArrow,\n          position: tooltip.placement,\n          arrowSize,\n          arrowOffset,\n          arrowRadius,\n          arrowPosition,\n          ...getStyles(\"arrow\")\n        }\n      )\n    )\n  )), cloneElement(\n    children,\n    tooltip.getReferenceProps({\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n      onMouseMove: props.onMouseMove,\n      onPointerDown: props.onPointerDown,\n      onPointerEnter: props.onPointerEnter,\n      [refProp]: targetRef,\n      className: cx(className, children.props.className),\n      ...children.props\n    })\n  ));\n});\nTooltip.classes = classes;\nTooltip.displayName = \"@mantine/core/Tooltip\";\nTooltip.Floating = TooltipFloating;\nTooltip.Group = TooltipGroup;\n\nexport { Tooltip };\n//# sourceMappingURL=Tooltip.mjs.map\n"],"names":["classes","defaultProps","Center","_props","ref","props","classNames","className","style","styles","unstyled","vars","inline","mod","others","getStyles","name","Box","displayName","assignRef","value","current","useMergedRef","refs","useCallback","node","forEach","mergeRefs","Array","isArray","type","elevations","app","modal","popover","overlay","max","getDefaultZIndex","level","DirectionContext","createContext","dir","toggleDirection","setDirection","useDirection","useContext","getFloatingPosition","position","includes","side","placement","split","flippedPosition","horizontalSide","arrowY","arrowOffset","arrowPosition","top","bottom","verticalSide","arrowX","left","radiusByFloatingSide","right","getArrowPositionStyles","arrowSize","arrowRadius","baseStyles","width","rem","height","transform","arrowPlacement","borderLeftColor","borderBottomColor","borderRightColor","borderTopColor","FloatingArrow","forwardRef","visible","Portal","children","target","mounted","setMounted","useState","nodeRef","useRef","document","querySelector","createElement","setAttribute","classList","add","filter","Boolean","Object","assign","id","createPortalNode","body","appendChild","removeChild","createPortal","OptionalPortal","withinPortal","defaultTransition","duration","transition","getStyleObject","theme","reduce","acc","item","isNode","nodeName","toLowerCase","_node$ownerDocument","ownerDocument","defaultView","window","getDocumentElement","_ref","documentElement","Node","Element","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","element","overflow","overflowX","overflowY","display","getComputedStyle","test","isTableElement","isContainingBlock","webkit","isWebKit","css","perspective","containerType","backdropFilter","some","willChange","contain","CSS","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getParentNode","result","assignedSlot","parentNode","host","getNearestOverflowAncestor","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","concat","visualViewport","frameElement","doc","activeElement","_activeElement","shadowRoot","parent","child","rootNode","getRootNode","contains","next","uaData","navigator","userAgentData","platform","brands","map","brand","version","join","userAgent","event","isAndroid","pressure","detail","pointerType","re","strict","values","push","undefined","isEventTargetWithin","composedPath","e","TYPEABLE_SELECTOR","matches","Math","min","round","floor","createCoords","v","x","y","oppositeSideMap","oppositeAlignmentMap","start","end","clamp","param","axis","getAxisLength","getAlignmentAxis","replace","alignment","getOppositePlacement","getPaddingObject","padding","expandPaddingObject","rectToClientRect","rect","computeCoordsFromPlacement","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","async","state","options","_await$platform$isEle","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","getClippingRect","isElement","contextElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","getBoundingRect","minX","minY","fn","_middlewareData$offse","_middlewareData$arrow","middlewareData","diffCoords","isRTL","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","convertValueToCoords","offset","arrow","alignmentOffset","data","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","topLayerSelectors","isTopLayer","selector","getWindowScrollBarX","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","direction","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","getTrueOffsetParent","polyfill","currentNode","getContainingBlock","topLayer","clippingAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","getClippingElementAncestors","this","_c","firstClippingAncestor","clippingRect","accRect","getElementRects","getOffsetParentFn","getDimensionsFn","getDimensions","getClientRects","from","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","addEventListener","passive","cleanupIo","onMove","timeoutId","io","root","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","observe","observeMove","frameId","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","removeEventListener","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","_middlewareData$flip","initialPlacement","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","isBasePlacement","oppositePlacement","getExpandedPlacements","isStart","lr","rl","tb","bt","getSideList","getOppositeAxisPlacements","placements","overflows","overflowsData","flip","sides","length","mainAlignmentSide","every","_middlewareData$flip2","_overflowsData$filter","nextIndex","index","nextPlacement","reset","resetPlacement","d","sort","a","b","_overflowsData$map$so","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","shouldAddOffset","centerOffset","nativeClientRects","clientRects","sortedRects","slice","groups","prevRect","i","getRectsByLine","fallback","resetRects","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","Map","mergedOptions","platformWithCache","config","middleware","validMiddleware","statefulPlacement","resetCount","nextX","nextY","computePosition","useLayoutEffect","useEffect","deepEqual","toString","keys","hasOwnProperty","call","key","$$typeof","getDPR","devicePixelRatio","roundByDPR","dpr","useLatestRef","useSafeInsertionEffect","useEffectEvent","callback","_len","arguments","args","_key","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","horizontalKeys","verticalKeys","serverHandoffComplete","count","genId","useId","setId","createPubSub","emit","_map$get","handler","on","listener","off","_map$get2","l","FloatingNodeContext","FloatingTreeContext","useFloatingParentNodeId","_React$useContext","useFloatingTree","createAttribute","safePolygonIdentifier","getDelay","prop","useHover","context","open","onOpenChange","dataRef","events","domReference","enabled","delay","handleClose","mouseOnly","restMs","move","tree","parentId","handleCloseRef","delayRef","pointerTypeRef","timeoutRef","handlerRef","restTimeoutRef","blockMouseMoveRef","performedPointerEventsMutationRef","unbindMouseMoveRef","isHoverOpen","_dataRef$current$open","openEvent","onLeave","closeWithDelay","runElseBranch","reason","closeDelay","cleanupMouseMoveHandler","clearPointerEvents","pointerEvents","removeAttribute","onScrollMouseLeave","onMouseEnter","once","onMouseLeave","isClickLikeOpenEvent","openDelay","clientX","clientY","onClose","relatedTarget","_handleCloseRef$curre","__options","blockPointerEvents","_tree$nodesRef$curren","parentFloating","nodesRef","setPointerRef","onPointerDown","onPointerEnter","onMouseMove","nativeEvent","FloatingDelayGroupContext","initialDelay","timeoutMs","currentId","setCurrentId","setState","isInstantPhase","useDelayGroupContext","FloatingDelayGroup","prev","initialCurrentIdRef","Provider","useDelayGroup","_ref2","_ref3","close","unset","timeout","getChildren","nodes","allChildren","_node$context","currentChildren","_currentChildren","n","_node$context2","bubbleHandlerKeys","pointerdown","mousedown","click","captureHandlerKeys","normalizeProp","normalizable","_normalizable$escapeK","_normalizable$outside","escapeKey","outsidePress","useDismiss","nodeId","unstable_outsidePress","outsidePressEvent","referencePress","referencePressEvent","bubbles","capture","outsidePressFn","insideReactTreeRef","endedOrStartedInsideRef","escapeKeyBubbles","outsidePressBubbles","escapeKeyCapture","outsidePressCapture","closeOnEscapeKeyDown","stopPropagation","shouldDismiss","_child$context","__escapeKeyBubbles","isReactEvent","closeOnEscapeKeyDownCapture","_getTarget2","_getTarget","closeOnPressOutside","insideReactTree","endedOrStartedInside","inertSelector","markers","querySelectorAll","targetRootAncestor","nextParent","marker","canScrollX","canScrollY","xCond","offsetX","offsetY","targetIsInsideChildren","_child$context2","__outsidePressBubbles","closeOnPressOutsideCapture","_getTarget4","_getTarget3","onScroll","_doc$defaultView","onKeyDown","onMouseDown","onMouseUp","_options$elements2","unstable_onOpenChange","_domReference","setDomReference","externalReference","externalFloating","whileElementsMounted","setData","isPositioned","latestMiddleware","setLatestMiddleware","_reference","_setReference","_floating","_setFloating","setReference","referenceRef","setFloating","floatingRef","floatingEl","hasWhileElementsMounted","whileElementsMountedRef","platformRef","then","fullData","isMountedRef","floatingStyles","initialStyles","useFloating","nested","domReferenceRef","floatingId","setPositionReference","positionReference","useFocus","visibleOnly","blockFocusRef","keyboardModalityRef","onBlur","onFocus","vendor","startsWith","maxTouchPoints","Error","movedToFocusGuard","hasAttribute","getAttribute","activeEl","ACTIVE_KEY","SELECTED_KEY","mergeProps","userProps","propsList","elementKey","isItem","domUserProps","_","__","validProps","tabIndex","propsOrGetProps","indexOf","has","val","componentRoleToAriaRoleMap","useRole","_componentRoleToAriaR","role","ariaRole","referenceId","isNested","floatingProps","active","selected","commonProps","refProp","zIndex","varsResolver","radius","color","tooltip","TooltipFloating","factory","label","multiline","disabled","variant","portalProps","rootSelector","handleMouseMove","opened","boundaryRef","setOpened","horizontalOffset","verticalOffset","parents","useFloatingTooltip","targetRef","cloneElement","TooltipGroupContext","TooltipGroupProvider","TooltipGroup","__useId","staticId","reactId","uuid","setUuid","random","useTooltip","settings","uncontrolledOpened","setUncontrolledOpened","withinGroup","uid","groupDelay","onChange","_opened","arrowRef","getReferenceProps","getFloatingProps","deps","getItemProps","useInteractions","hover","touch","focus","positionDependencies","delayedUpdate","setDelayedUpdate","c","useFloatingAutoUpdate","onPositionChange","isGroupPhase","transitionProps","Tooltip","withArrow","onClick","keepMounted","floatingStrategy","componentTransition","getTransitionProps","Transition","transitionStyles","Floating","Group"],"sourceRoot":""}